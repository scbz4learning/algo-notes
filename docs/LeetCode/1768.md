---
title: 1768. Merge Strings Alternately
tags:
  - none
  - too easy
---

## Question 
> **题目：交替合并字符串**
>
> 给定两个字符串 `word1` 和 `word2`，按照交替的顺序将它们合并，从 `word1` 开始。如果一个字符串比另一个长，将多出来的字母附加到合并字符串的末尾。
>
> 返回合并后的字符串。
>
> **例子 1**：
> 输入: `word1 = "abc"`, `word2 = "pqr"`  
> 输出: `"apbqcr"`
>
> **解释**：
> 合并后的字符串将按以下方式合并：
> ```
> word1:  a   b   c
> word2:    p   q   r
> merged: a p b q c r
> ```
>
> **例子 2**：
> 输入: `word1 = "ab"`, `word2 = "pqrs"`  
> 输出: `"apbqrs"`
>
> **解释**：
> 由于 `word2` 更长，`"rs"` 会被附加到末尾：
> ```
> word1:  a   b 
> word2:    p   q   r   s
> merged: a p b q   r   s
> ```
>
> **例子 3**：
> 输入: `word1 = "abcd"`, `word2 = "pq"`  
> 输出: `"apbqcd"`
>
> **解释**：
> 由于 `word1` 更长，`"cd"` 会被附加到末尾：
> ```
> word1:  a   b   c   d
> word2:    p   q 
> merged: a p b q c   d
> ```
>
> **限制**：
> - 1 <= `word1.length`, `word2.length` <= 100
> - `word1` 和 `word2` 由小写英文字母组成。

## Solution

```cpp
class Solution {
public:
    string mergeAlternately(string word1, string word2) {
        string ans;
        for (int i = 0; i < word1.size() || i < word2.size(); i++){
            if (i < word1.size()) ans.push_back(word1[i]);
            if (i < word2.size()) ans.push_back(word2[i]);
        }
        return ans;
    }
};
```

String has no `append`.