---
title: 605. Can Place Flowers
tags: 
  - math
  - easy
---

## Question

> **题目：能否种植花朵**
>
> 给定一个长花坛 `flowerbed`，其中一些位置已经种植了花，其他位置则没有花。但是，相邻的两个位置不能种植花。
>
> 给定一个整数数组 `flowerbed`，其中 0 表示空地，1 表示已经种植了花，并且给定一个整数 `n`，如果可以在花坛中种植 `n` 朵新花且不违反相邻花朵不能种植的规则，则返回 `true`，否则返回 `false`。
>
> **例子 1**：
> 输入: `flowerbed = [1,0,0,0,1]`, `n = 1`  
> 输出: `true`
>
> **例子 2**：
> 输入: `flowerbed = [1,0,0,0,1]`, `n = 2`  
> 输出: `false`
>
> **限制**：
> - `1 <= flowerbed.length <= 2 * 10^4`
> - `flowerbed[i]` 为 0 或 1。
> - `flowerbed` 中没有两个相邻的花。
> - `0 <= n <= flowerbed.length`

## Solution
```cpp
class Solution {
public:
    bool canPlaceFlowers(vector<int>& flowerbed, int n) {
        int c = 1;
        for (int i = 0; i < flowerbed.size(); i++) {
            if (flowerbed[i] == 0) {
                c++;
            }
            else {
                n -= (c - 1) / 2;
                c = 0;
            }
        }
        n -= c / 2;
        return n<=0;
    }
};
```

## 总结
关键在于, 想明白 generalised 的情况.

1. 两个 `1` 之间: 
    1. `11` -> 放不下
    2. `101` -> 放不下
    3. `1001` -> 放不下
    4. `10001` -> 放下 1 个
    5. `100001` -> 放下 1 个
    6. `1000001` -> 放下 2 个
    
    所以, $(\#0 - 1) / 2$.  
2. 头上:
    1. `1` -> 放不下
    2. `01` -> 放不下
    3. `001` -> 放下 1 个 

    所以 $\#0 / 2$. 
3. 尾上同头上

->
1. 直接 Naive 先做头尾 -> 在判断中间
2. 把头等效成 `10` 开头, 这样也就是说, 头上隐含有一个 0, 之后除了尾部, 判断 `1..1` 的方式都一样. 尾部最后判断就行. 
3. 注意考虑全 `0` 的情况, Naive 别算两遍, 然后要验证等效法不需要额外的环节.