---
title: 334. Increasing Triplet Subsequence
tags: 
  - medium
---

## Question

> **题目：递增的三元子序列**
>
> 给定一个整数数组 `nums`，如果存在一组三个索引 `(i, j, k)`，使得 `i < j < k` 且 `nums[i] < nums[j] < nums[k]`，则返回 `true`；如果不存在这样的三元子序列，返回 `false`。
>
> **例子 1**：
> 输入: `nums = [1,2,3,4,5]`  
> 输出: `true`
>
> **解释**：
> 任何符合 `i < j < k` 的三元组都有效。
>
> **例子 2**：
> 输入: `nums = [5,4,3,2,1]`  
> 输出: `false`
>
> **解释**：
> 不存在符合条件的三元组。
>
> **例子 3**：
> 输入: `nums = [2,1,5,0,4,6]`  
> 输出: `true`
>
> **解释**：
> 有一个有效的三元组 `(1, 4, 5)`，因为 `nums[1] == 1 < nums[4] == 4 < nums[5] == 6`。
>
> **限制**：
> - `1 <= nums.length <= 5 * 10^5`
> - `-2^31 <= nums[i] <= 2^31 - 1`

## Solution

### Approach 1: Two Arrays (Intuitive)

如果想不到贪心策略，可以使用更直观的“预处理”方法（空间换时间）。
核心思想：对于任意位置 `i`，如果它左边的最小值比它小，且它右边的最大值比它大，那么就找到了三元组。

1. 构建 `leftMin` 数组，`leftMin[i]` 记录 `0...i` 的最小值。
2. 构建 `rightMax` 数组，`rightMax[i]` 记录 `i...n-1` 的最大值。
3. 遍历数组（从索引 1 到 n-2），检查是否满足 `leftMin[i-1] < nums[i] < rightMax[i+1]`。

#### Code

```cpp
class Solution {
public:
    bool increasingTriplet(vector<int>& nums) {
        int n = nums.size();
        if (n < 3) return false;

        // 1. 预处理左边的最小值
        vector<int> leftMin(n);
        leftMin[0] = nums[0];
        for (int i = 1; i < n; i++) {
            leftMin[i] = min(leftMin[i - 1], nums[i]);
        }

        // 2. 预处理右边的最大值
        vector<int> rightMax(n);
        rightMax[n - 1] = nums[n - 1];
        for (int i = n - 2; i >= 0; i--) {
            rightMax[i] = max(rightMax[i + 1], nums[i]);
        }

        // 3. 遍历中间元素，判断是否符合条件
        for (int i = 1; i < n - 1; i++) {
            if (leftMin[i - 1] < nums[i] && nums[i] < rightMax[i + 1]) {
                return true;
            }
        }

        return false;
    }
};
```

- **Time Complexity**: $O(N)$
- **Space Complexity**: $O(N)$

---

### Approach 2: Greedy (Space Optimized)

这是最优解，但逻辑较为巧妙。维护两个变量 `first` 和 `second`，分别表示递增三元组中的第一个数和第二个数。

1. 初始化 `first = INT_MAX`, `second = INT_MAX`。
2. 遍历数组 `nums`：
   - 如果 `num <= first`，更新 `first = num`。
   - 否则如果 `num <= second`，更新 `second = num`。
   - 否则（即 `num > second`），说明找到了第三个数，返回 `true`。

**为什么这个算法有效？**
虽然 `first` 可能会被更新为更小的值（导致它和当前的 `second` 在原数组中顺序不对），但 `second` 的存在本身就意味着**“在它之前有一个比它小的数”**。只要找到比 `second` 大的数，就能构成三元组。

#### Code

```cpp
class Solution {
public:
    bool increasingTriplet(vector<int>& nums) {
        int first = INT_MAX;
        int second = INT_MAX;

        for (int num : nums) {
            if (num <= first) {
                first = num; // 找到更小的第一个数
            } else if (num <= second) {
                second = num; // 找到比 first 大但比 second 小的第二个数
            } else {
                return true; // 找到比 first 和 second 都大的第三个数
            }
        }

        return false;
    }
};
```

- **Time Complexity**: $O(N)$
- **Space Complexity**: $O(1)$

---

### Approach 3: Greedy (Traceable / Corrected)

标准的贪心算法虽然能正确判断 True/False，但它找到的 `first` 和 `second` 可能并不是最终三元组的一部分（如 `[3, 4, 1, 5]` 会导致 `first=1, second=4`，虽然判断正确，但 `1, 4, 5` 不是合法子序列）。

如果我们想要**返回具体的三元组**，或者逻辑上更严谨地维护 `first` 和 `second`，我们可以引入一个 `min_val` 变量作为“候选起点”。

**逻辑修正：**
只有当我们找到了一个能和 `min_val` 配对的数（即 `num > min_val`）且这个配对优于当前的 `(first, second)` 时，我们才更新 `first` 和 `second`。

#### Code

```cpp
class Solution {
public:
    bool increasingTriplet(vector<int>& nums) {
        if (nums.size() < 3) return false;

        int min_val = INT_MAX;    // 候选最小值 (Possible Min)
        int first = INT_MAX;      // 有效 Pair 的第一个值
        int second = INT_MAX;     // 有效 Pair 的第二个值

        for (int num : nums) {
            if (num <= min_val) {
                min_val = num; // 1. 发现更小的数，记录为候选起点
            } else if (num <= second) {
                // 2. num > min_val 且 num <= second
                // 说明找到了一个以 min_val 为起点，num 为终点的 Pair (min_val, num)
                // 这个 Pair 的终点比原来的 second 更小（或相等），因此更优
                // 此时我们才正式更新 first 和 second，保证它们是一对合法的索引对
                first = min_val;
                second = num;
            } else {
                // 3. num > second
                // 说明找到了 (first, second, num)
                // 打印找到的三元组
                cout << "Found: " << first << ", " << second << ", " << num << endl;
                return true;
            }
        }
        return false;
    }
};
```

**解释：**
以 `[3, 4, 1, 5]` 为例：
1. `3`: `min_val = 3`。
2. `4`: `4 > min_val`，更新 `first = 3`, `second = 4`。
3. `1`: `1 < min_val`，更新 `min_val = 1`。注意此时 `first` 仍为 3，`second` 仍为 4。我们只是记录 `1` 是个更好的潜在起点。
4. `5`: `5 > second` (4)。返回 `true`，并且可以打印出 `3, 4, 5`。

这种方法既保留了 $O(1)$ 的空间复杂度，又能保证 `first` 和 `second` 始终指向原数组中真实存在的、顺序正确的元素对。
