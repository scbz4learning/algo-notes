---
title: 1679. Max Number of K-Sum Pairs
tags: 
  - two pointers
  - medium
---

## Question

> **题目：最大数目的 K 和配对**
>
> 给定一个整数数组 `nums` 和一个整数 `k`。
>
> 在一次操作中，你可以从数组中选出两个数，使它们的和等于 `k`，并将它们从数组中移除。
>
> 返回你可以在数组上执行的最大操作次数。
>
> **例子 1**：
> 输入: `nums = [1,2,3,4]`, `k = 5`  
> 输出: `2`
>
> **解释**：
> 从 `nums = [1,2,3,4]` 开始：
> - 移除数字 1 和 4，剩下 `nums = [2,3]`
> - 移除数字 2 和 3，剩下 `nums = []`
> 不再有和为 5 的配对，因此总操作次数为 2。
>
> **例子 2**：
> 输入: `nums = [3,1,3,4,3]`, `k = 6`  
> 输出: `1`
>
> **解释**：
> 从 `nums = [3,1,3,4,3]` 开始：
> - 移除前两个 3，剩下 `nums = [1,4,3]`
> 不再有和为 6 的配对，因此总操作次数为 1。
>
> **限制**：
> - `1 <= nums.length <= 10^5`
> - `1 <= nums[i] <= 10^9`
> - `1 <= k <= 10^9`


## Solution

### Naive

```cpp
class Solution {
public:
    int maxOperations(vector<int>& nums, int k) {
        int ans = 0; 
        int count = 1; // number of pair.left
        sort(nums.begin(), nums.end());

        int i = 0, j = nums.size() - 1;
        while (i < j) {
            // count is the 
            while (i < j && nums[i] == nums[i+1]) {
                count++;
                i++;
            }

            // i is the last replicated nums[i]
            int cur = nums[i];

            // j-- to find possible j
            // , such that nums[j] = k - nums[i]
            while (i < j && cur + nums[j] > k) {
                j--;
            }

            // find pairs can be deleted
            if (cur + nums[j] == k) {
                while (i < j && cur + nums[j] == k) {
                    // update ans if #left is enough
                    if (count > 0) {
                        count--;
                        ans++;
                    }
                    j--;
                }

                if (i == j && cur * 2 == k) {
                    ans += count / 2;
                    break;
                }
            }

            // else
            // nums[i] + max(num[j]) is not enough
            // all nums[i] cannot be deleted

            i++;
            count = 1;
        }
        return ans;
    }
};
```

### Better

```cpp
class Solution {
public:
    int maxOperations(vector<int>& nums, int k) {
        int ans = 0; 
        sort(nums.begin(), nums.end());

        int i = 0, j = nums.size() - 1;
        while (i < j) {
            int sum = nums[i] + nums[j];
            if (sum > k) {
                j--;
            } 
            else if (sum == k) {
                ans++;
                i++;
                j--;
            }
            else {
                i++;
            }
        }
        return ans;
    }
};
```

## 总结

while 中单步 比 while 套 while 好的多.
主要是不容易错