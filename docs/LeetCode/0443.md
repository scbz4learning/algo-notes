---
title: 443. String Compression
tags: 
  - medium
---

## Question

> **题目：字符串压缩**
>
> 给定一个字符数组 `chars`，使用以下算法对其进行压缩：
>
> 从一个空字符串 `s` 开始。对于 `chars` 中的每一组连续重复的字符：
> 
> - 如果该组的长度为 1，直接将字符添加到 `s`。
> - 否则，将字符后面跟上该组的长度。
>
> 压缩后的字符串 `s` 不需要单独返回，而是应该存储在输入的字符数组 `chars` 中。注意，如果组的长度为 10 或更长，长度会被拆成多个字符存储在 `chars` 中。
>
> 完成修改后，返回数组的新长度。
>
> 你必须编写一个只使用常数额外空间的算法。
>
> **注意**：返回长度后的字符数组部分可以忽略。
>
> **例子 1**：
> 输入: `chars = ["a","a","b","b","c","c","c"]`  
> 输出: `6`，且输入数组前 6 个字符应为 `["a","2","b","2","c","3"]`  
> 
> **解释**：
> 组为 "aa", "bb", "ccc"。压缩结果为 "a2b2c3"。
>
> **例子 2**：
> 输入: `chars = ["a"]`  
> 输出: `1`，且输入数组的第一个字符应为 `["a"]`  
> 
> **解释**：
> 只有一个字符 "a"，所以它保持不变。
>
> **例子 3**：
> 输入: `ch

## Solution
### 原地?

!!! note "Can I `erase()` or `insert()` on `vector` while iterating?"

    事实上可以. 但是并没有好处.

    只要记得对 `it` 重新赋值, 程序就不会错误. 比如:
    
    ```cpp
    for (auto it = vec.begin(); it != vec.end(); ) {
        if (*it % 2 == 0) {  // Example condition: insert 0 before even numbers
            it = vec.insert(it, 0);  // Insert 0 at the current position, iterator points to 0
            // Or erase
            // it = vec.erase(it);  // erase returns the next valid iterator
            ++it;  // Move to the next element after the inserted one
        } else {
            ++it;  // Only increment if not inserting
        }
    }
    ```

    但是这样并不好. 因为 insert 和 erase 都是 `O(n)` 的.

    更好的办法还是, 新建一个 `newVec`, 最后 `vec = newVec`

!!! Warning "但是要把原地写对并不容易"

### AC 
```cpp
class Solution {
public:
    int compress(vector<char>& chars) {
        vector<char> ans {chars[0]};
        char last = chars[0];
        int i = 1;
        while (i < chars.size()) {
            if (chars[i] == last) {
                int count = 2; // cur = last, now has 2 replication
                // current i is judged
                // Now need to check the next pos
                // first perfome ++i
                while (++i < chars.size() && chars[i] == last) {
                    count++;
                }
                // i is now the first non-replicated char
                // there is no need to perform i++ in this iteration now
                vector<char> charCount;
                while (count) {
                    charCount.push_back('0' + count % 10);
                    count /= 10;
                }
                for (auto itCur = charCount.rbegin()
                    ; itCur != charCount.rend()
                    ; itCur++)
                {
                    ans.push_back(*itCur);
                }
            }
            else {
                last = chars[i];
                ans.push_back(last);
                i++;
            }
        }
        chars = ans;
        return ans.size();
    }
};
```

### `to_string` 是 `<string>` 包含的.

所以 `count` 那里可以直接:

```cpp
for (char c : to_string(count)) {
    ans.push_back(c);
}
```

??? Quote "对比 `Naive`"
    ```cpp
    vector<char> charCount;
    while (count) {
        charCount.push_back('0' + count % 10);
        count /= 10;
    }
    for (auto itCur = charCount.rbegin()
        ; itCur != charCount.rend()
        ; itCur++)
    {
        ans.push_back(*itCur);
    }
    ```

## 思考
### `insert()`

+ 参数: 插入到 pos 前
    1. `insert(pos, count, value)`; 右值可复制
    2. `insert(pos, It first, It last)`;
+ 返回值: **Iterator, 指向第一个插入的值 (如果没插入, 指向pos)**
         
### `erase()`

+ 参数: 插入到 pos 前
    1. `erase(pos)`;
    2. `erase(It first, It last)`; 删除 \[first, last\), **不含 last**
+ 返回值: **Iterator, 指向 last (可以是 `end()`)**


### 怎么让代码变得 elegant?

事实上, 上面的code 是经过修改的:

<div style="display: flex; justify-content: space-between;">
  <div style="width: 49%;">
    ```cpp
    // 用 for 循环
    // 每次循环结束会自动 i++
    // 来到下一个元素
    for (int i = 1; i < chars.size(); i++) {
        if (chars[i] == last) {
            int count = 2; 
            while (
                ++i < chars.size() 
                && chars[i] == last
            ) 
            {
                count++;
            }

            // 这里被迫 i--, 
            // 因为已经到了下一个元素了 
            //     (chars[i]!=last)
            // 如果不i--, 会跳过一个元素
            i--;

            for (char c : to_string(count)) {
                ans.push_back(c);
            }
        }
        else {
            last = chars[i];
            ans.push_back(last);
        }
    }
    ```
  </div>
  <div style="width: 49%;">
    ```cpp
    // 用 while 好很多
    // 因为只有一个分支要 i++
    
    while (i < chars.size()) {
        if (chars[i] == last) {
            int count = 2; 
            while (
                ++i < chars.size() 
                && chars[i] == last
            ) 
            {
                count++;
            }
            
            // 用 while
            // 只需要什么都不做




            for (char c : to_string(count)) {
                ans.push_back(c);
            }
        }
        else {
            last = chars[i];
            ans.push_back(last);

            // 只有一个分支需要 i++
            i++;
        }
    }
    ```
  </div>
</div>

