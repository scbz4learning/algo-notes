---
title: 11. Container With Most Water
tags: 
  - greedy
  - two pointers
  - medium
---

## Question

> **题目：盛最多水的容器**
>
> 给定一个整数数组 `height`，数组的长度为 `n`。其中有 `n` 条垂直线，第 `i` 条线的两个端点分别为 `(i, 0)` 和 `(i, height[i])`。
>
> 找出两条线，和 x 轴一起构成一个容器，使得容器能够容纳最多的水。
>
> 返回容器能够容纳的最大水量。
>
> 注意：你不能倾斜容器。
>
> **例子 1**：
> 输入: `height = [1,8,6,2,5,4,8,3,7]`  
> 输出: `49`
>
> **解释**：
> 上面的垂直线由数组 `[1,8,6,2,5,4,8,3,7]` 表示。在这种情况下，容器能够容纳的最大水量为 49。
>
> **例子 2**：
> 输入: `height = [1,1]`  
> 输出: `1`
>
> **限制**：
> - `n == height.length`
> - `2 <= n <= 10^5`
> - `0 <= height[i] <= 10^4`

## Solution
这个题需要最大的体积, 什么样的体积是最大的? 
    + 平衡的 x -> 隔壁考公去
    + **量化!** 怎么量化?
        1. 更高 -> `min(height[i], height[j])` 变大
        2. 更宽 -> `j - i` 更大

所以: 
1. 怎么遍历? 
    1. 双指针: 固定宽度递减, 高度只有增了才有可能体积更大
    2. 更新哪个指针? 高度永远是 `min(height[i], height[j])`, 所以更新更大的值没作用, 只能更新相对小的值.
2. 什么时候可能要更新体积? 
    1. 更高 -> `min(height[i], height[j])` 变大 -> 维护一个 `curMaxheight`
    2. 更宽 -> `j - i` 更大, 也就是更早搜索的

```cpp
class Solution {
public:
    int maxArea(vector<int>& height) {
        int i = 0, j = height.size() - 1;
        int curMaxHeight = min(height[i], height[j]);
        int ans = curMaxHeight * (j - i);
        while (i < j) {
            if (height[i] < height[j]) {
                if (height[++i] > curMaxHeight)
                    ans = max(
                        ans,
                        min(height[i], height[j]) * (j - i)
                    );
            } else {
                if (height[--j] > curMaxHeight)
                    ans = max(
                        ans,
                        min(height[i], height[j]) * (j - i)
                    );
            }
        }
        return ans;
    }
};
```

事实上, 不需要维护 `curMaxHeight` 可以更快, 每次直接判断就行. 因为即使判断了, 也不能证明提及一定会更大, 所以判断运算了一次, 但是只能排除一部分结果.


??? note "为啥?"

    其实这个结论未必正确. 但是 simulation 的结果确实是这样的.

    [不维护](https://leetcode.com/problems/container-with-most-water/submissions/1854286216) vs [维护](https://leetcode.com/problems/container-with-most-water/submissions/1854297768)

    可能的解释是:

    - 最快的 cache 取指或者取数据, 也要比 ALU 读 register & 算一次更慢
        - 可能是访存确实更慢
        - 可能是流水线充分利用了访存的时间
        - 可能是 -O2 优化带来的
    - test case 中的元素数量总体更小

```cpp
class Solution {
public:
    int maxArea(vector<int>& height) {
        int i = 0, j = height.size() - 1;
        int ans = min(height[i], height[j]) * (j - i);
        while (i < j) {
            if (height[i] < height[j]) {
                ans = max(
                    ans,
                    min(height[++i], height[j]) * (j - i)
                );
            } else {
                ans = max(
                    ans,
                    min(height[i], height[--j]) * (j - i)
                );
            }
        }
        return ans;
    }
};
```